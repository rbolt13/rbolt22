{
  "hash": "cfbca69d1e200a9b96659a4e4f1bd222",
  "result": {
    "markdown": "---\ntitle: \"Tidyverse Style Guide (Part 1)\"\ndate: \"2022-07-25\"\ncategories: [R]\ntoc: true\n---\n\n\nThis is part 1 of my notes on [the tidyverse style guide](https://style.tidyverse.org/).\n\n![tidyverse hex](../../00_img/tidyverse.png)\n\n\n::: {.cell}\n\n:::\n\n\n# `1.` Set Up\n\nThis post will use two packages:\n\n* tidyverse: a collection of R packages designed for data science.\n\n* datasets: a collection of data sets. \n\nThis post will only be looking at one data set:\n\n* iris: 50 samples of 3 species of Iris's. \n\nLastly to save two variables, which will be used throughout this post. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# packages\nlibrary(tidyverse)\nlibrary(datasets)\n# data\ndata(iris)\n# variables\nx <- 1\ny <- 2\n```\n:::\n\n\n# `2.` Analysis \n\n## `2.1` Files\n\n- names are meaningful and use letters, numbers, `_`, and/or `-`. \n\n- avoid special characters in files names. \n\n- if more than 10 files then left pad with a zero (i.e. 00, 01, 02, 03,...)\n\n- rename files instead of attempting 02a, 02b, and so on.  \n\n- pay attention to capitalization. \n\n- load all packages at once in the beginning of the file. \n\n- use `-` and `=` to break up file into readable chunks. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load data ---------------------------\n\n# Plot data ---------------------------\n```\n:::\n\n\n## `2.2` Syntax\n\n### `2.2.1` Object Names\n\n- Variables and function names should use lowercase letters, numbers and `_` (no camel case).\n\n- Base R uses dots in function and class names (`data.frame`).\n\n- Variable names should be names and nouns. \n\n- Function names should be verbs. \n\n- Names should be concise and meaningful. \n\n- Avoid re-using names of common function and variables. \n\n### `2.2.2` Spacing\n\n- Put a space after a common, never before. \n\n- Do not put spaces inside or outside parentheses for regular functions : `mean(x, na.rm = TRUE)`. \n\n- Put a space before and after () when using if, for, or while.\n\n- Place a space after `()` used for function arguments : `function(x) {}`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# if (debug) {\n#   show(x)\n# }\n```\n:::\n\n\n- The embracing operator, `{{ }}`, should always have inner spaces to help emphasize its special behavior.\n\n- Most infix operators (`==`, `+`, `-`, `<-`, etc.) should always be surrounded by spaces.\n\n- Exceptions being: \n\n  - The operators with high precedence: `::`, `:::`, `$`, `@`, `[`, `[[`, `^`, `unary -`, `unary +`, and `:`.\n  \n  - Single-sided formulas when the right-hand side is a single identifier: `call(!!xyz)`.\n  \n  - When used in tidy evaluation `!!` (bang-bang) and `!!!` (bang-bang-bang) (because have precedence equivalent to unary `-/+`).\n  \n  - The helper operator: `package?stats`.\n  \n- adding extra spaces is ok if it improves alignment of `=` or `<-`.\n\n### `2.2.3` Function Calls\n\n- When you call a function omit the names of data arguemnts (such as `x=` because it is used so commonly).\n\n- If you override the default value of an argument, use the full name.\n\n- Avoid assignments in function calls.\n\n  - Exception: function that capture side-effects: `output <- capture.output(x <- f())`.\n  \n### `2.2.4` Control Flow\n\n- For `{}` brackets: \n\n  - `{` should be the last character on the line. \n  \n  - Contents should be indented by two spaces. \n  \n  - `}` should be the first character on the line. \n  \n  - Else should be on the same line as `}` (if used).\n  \n- `{}` define the most important hierarchy of R code.\n\n- Always use `&&` and `||` inside an if clause and never `&` and `|`. \n\n- If you want to rewrite a simple but lengthy if block:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (x > 10) {\n  message <- \"big\"\n} else {\n  message <- \"small\"\n}\n```\n:::\n\n\nJust write it all on one line:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmessage <- if (x > 10) \"big\" else \"small\"\n```\n:::\n\n\n- it is okay to drop curly braces for very simple statements that fit on one line as long as they don't have side-effects.\n\n- Function calls that affect control flow (like return(), stop() or continue) should always go in their own {} block.\n\n- Avoid implicit type coercion (e.g. from numeric to logical) in if statements:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Good\nif (length(x) > 0) {\n  # do something\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNULL\n```\n:::\n\n```{.r .cell-code}\n# Bad\nif (length(x)) {\n  # do something\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNULL\n```\n:::\n:::\n\n\n- Avoid position-based `switch()` statements. \n\n- Each element should go on its own line. \n\n- Provided a fall-through arrow, unless you have previously validate the input. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nswitch(x, \n  a = 0,\n  b = 1, \n  c = 2,\n  stop(\"Unknown `x`\", call. = FALSE)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n:::\n\n\n### `2.2.5` Long Lines\n\n- Limit code to 80 characters per line. This fits comfortably on a printed page with a reasonably sized font. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# # Good\n# do_something_very_complicated(\n#   something = \"that\",\n#   requires = many,\n#   arguments = \"some of which may be long\"\n# )\n# \n# # Bad\n# do_something_very_complicated(\"that\", requires, many, arguments,\n#                               \"some of which may be long\"\n#                               )\n```\n:::\n\n\n- You may also place several arguments on the same line if they are closely related to each other, e.g., strings in calls to paste() or stop().\n\n### `2.2.6` Semicolons\n\n- Don’t put ; at the end of a line, and don’t use ; to put multiple commands on one line.\n\n### `2.2.7` Assignment\n\n- Use `<-`, not `=`, for assignment.\n\n### `2.2.8` Data\n\n- Use `\"`, not `'`, for quoting text. The only exception is when the text already contains double quotes and no single quotes.\n\n- Prefer TRUE and FALSE over T and F.\n\n### `2.2.9` Comments\n\n- Each line of a comment should begin with the comment symbol and a single space.\n\n- In data analysis code, use comments to record important findings and analysis decisions.\n\n- If you need comments to explain what your code is doing, consider rewriting your code to be clearer. \n\n- If you discover that you have more comments than code, consider switching to R Markdown.\n\n## `2.3` Functions\n\n### `2.3.1` Naming\n\n- Strive to use verbs for function names.\n\n### `2.3.2` Long Lines\n\n- Prefer function-indent style to double-indent style when it fits. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Function-indent --------------------------------------\nlong_function_name <- function(a = \"a long argument\",\n                               b = \"another argument\",\n                               c = \"another long argument\") {\n  # As usual code is indented by two spaces.\n}\n\n# Double-indent ----------------------------------------\nlong_function_name <- function(\n    a = \"a long argument\",\n    b = \"another argument\",\n    c = \"another long argument\") {\n  # As usual code is indented by two spaces.\n}\n```\n:::\n\n\n- If a function argument can’t fit on a single line, this is a sign you should rework the argument to keep it short and sweet.\n\n### `2.3.3` return()\n\n- Only use return() for early returns. Otherwise, rely on R to return the result of the last evaluated expression.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Good\nfind_abs <- function(x) {\n  if (x > 0) {\n    return(x)\n  }\n  x * -1\n}\nadd_two <- function(x, y) {\n  x + y\n}\n\n# Bad\nadd_two <- function(x, y) {\n  return(x + y)\n}\n```\n:::\n\n\n- Return statements should always be on their own line because they have important effects on the control flow. \n\n- If your function is called primarily for its side-effects (like printing, plotting, or saving to disk), it should return the first argument invisibly. This makes it possible to use the function as part of a pipe.\n\n### `2.3.4` Comments\n\n- In code, use comments to explain the “why” not the “what” or “how”.\n\n- Comments should be in sentence case, and only end with a full stop if they contain at least two sentences. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Good -----------------------------------------\n\n# Objects like data frames are treated as leaves\n\n# Do not use `is.list()`. Objects like data frames \n# must be treated as leaves.\n\n# Bad -----------------------------------------\n\n# objects like data frames are treated as leaves\n\n# Objects like data frames are treated as leaves.\n```\n:::\n\n\n## `2.4` Pipes\n\n### `2.4.1` Introduction\n\n- Reserve pipes for a sequence of steps applied to one primary object.\n\n- Avoid using pipes when there are meaningful intermediate objects that could be given informative names.\n\n### `2.4.2` Withespace\n\n- `%>%` should always have a space before it, and should usually be followed by a new line. After the first step, each line should be indented by two spaces.\n\n### `2.4.3` Long Lines\n\n- If the arguments to a function don’t all fit on one line, put each argument on its own line and indent. \n\n### `2.4.4` Short Pipes\n\n- A one-step pipe can stay on one line, but unless you plan to expand it later on, you should consider rewriting it to a regular function call.\n\n- Sometimes it’s useful to include a short pipe as an argument to a function in a longer pipe. Carefully consider whether the code is more readable with a short inline pipe (which doesn’t require a lookup elsewhere) or if it’s better to move the code outside the pipe and give it an evocative name.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Good\n# x %>%\n#   select(a, b, w) %>%\n#   left_join(y %>% select(a, b, v), by = c(\"a\", \"b\"))\n# \n# # Better\n# x_join <- x %>% select(a, b, w)\n# y_join <- y %>% select(a, b, v)\n# left_join(x_join, y_join, by = c(\"a\", \"b\"))\n```\n:::\n\n\n### `2.4.5` No Arguments\n\n- magrittr allows you to omit () on functions that don’t have arguments. Avoid this feature.\n\n### `2.4.6` Assignment\n\nThere are three acceptable forms of assignment:\n\n- Variable name and assignment on separate lines:\n\n\n::: {.cell}\n\n```{.r .cell-code}\niris_long <-\n  iris %>%\n  gather(measure, value, -Species) %>%\n  arrange(-value)\n```\n:::\n\n\n- Variable name and assignment on the same line:\n\n\n::: {.cell}\n\n```{.r .cell-code}\niris_long <- iris %>%\n  gather(measure, value, -Species) %>%\n  arrange(-value)\n```\n:::\n\n\n- Assignment at the end of the pipe with `->`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\niris %>%\n  gather(measure, value, -Species) %>%\n  arrange(-value) ->\n  iris_long\n```\n:::\n\n\n- The magrittr package provides the `%<>%` operator as a shortcut for modifying an object in place. Avoid this operator.\n\n## `2.5` ggplot2\n\n### `2.5.1` Introduction \n\n- Styling suggestions for `+` used to separate ggplot2 layers are very similar to those for `%>%` in pipelines.\n\n### `2.5.2` Whitespace\n\n- `+` should always have a space before it, and should be followed by a new line.\n\n- If you are creating a ggplot off of a dplyr pipeline, there should only be one level of indentation.\n\n### `2.5.3` Long lines \n\n- If the arguments to a ggplot2 layer don’t all fit on one line, put each argument on its own line and indent. \n\n- ggplot2 allows you to do data manipulation, such as filtering or slicing, within the data argument. Avoid this, and instead do the data manipulation in a pipeline before starting plotting.\n\n---\n\nTo be continued ... ",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}